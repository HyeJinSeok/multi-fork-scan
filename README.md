# 멀티프로세싱 기반 #include 카운터

<br>

이 프로젝트는 C 언어로 작성된 프로그램으로, 리눅스의 **fork( ) 시스템 호출**을 이용해 멀티 프로세싱 구조를 구현했습니다. <br>
**자식 프로세스**들이 디렉토리 내 .h 파일을 병렬로 분석하고 #include 문자열의 발생 횟수를 집계하여 **부모 프로세스**가 최종 결과를 출력합니다.

<br>

## 🔹실습 목표

<br>

- 리눅스의 `fork()` 시스템 호출을 활용한 멀티프로세싱 구조의 동작 원리를 이해한다.
- 부모-자식 프로세스 간의 역할 분담과 실행 흐름을 직접 구현하며 익힌다.
- 파일 탐색, 문자열 검색, 자식 프로세스 분기 등 실무에서 자주 쓰이는 **시스템 프로그래밍** 기법을 연습한다.
- **멀티프로세싱**과 **싱글프로세싱**의 성능을 비교하여 병렬 처리의 효과를 확인한다.
- 간단한 병렬 처리 구조를 구성해보며 추후 병렬/분산 처리 시스템에 대한 기초 감각을 익힌다.

  <br>

## 🔹학습 시기
📆 2023년 9월~11월

<br><br>

## 🔹프로젝트 개요

<br>

1. 멀티 프로세스란?
2. 부모-자식 프로세스 특징
3. 이 프로젝트에서의 적용 방식

<br>

### 1. 멀티 프로세스란?

멀티프로세싱(Multi-processing)은 하나의 프로그램이 여러 프로세스를 생성하여 작업을 **병렬로 처리**하는 방식 <br>
프로세스는 각각 독립적인 메모리와 자원을 사용하는 작업 단위임 <br>
대표적인 프로세스 생성 함수로 fork( )를 사용할 수 있음

<br>

### 2. 부모-자식 프로세스 특징

• fork( )를 호출한 프로세스가 부모 프로세스 <br>
• fork( )를 호출한 시점에서 바로 자식 프로세스 (=부모의 복사본) 생성됨 <br>

<br>

• 자식과 부모는 반환값을 통해 구분할 수 있음 <br>
> 부모: return 값이 **양수** <br> 자식: return 값이 **0** <br> fork( ) 실패 시: return값이 **-1**

<br>

※ fork( ) 이후에 두 프로세스는 동시에 독립적으로 실행되기 때문에, **부모-자식 간 실행 순서**는 보장되지 않음 <br>
> **좀비 프로세스**: 자식이 종료됐을 때 부모가 wait( )를 호출해 종료 상태를 수거해야 하지만, 그렇게 하지 않았을 때 리소스 낭비 발생 <br>
**고아 프로세스**: 부모가 자식보다 먼저 종료됐을 시 init(PID 1)이 대신 수거, 이를 방지하기 위해 부모는 wait( ) 이용해야 함

<br>

### 3. 이 프로젝트에서의 적용 방식

<br>

• 대상 디렉토리로 C/C++ 시스템 헤더 파일이 다수 위치한 **/usr/include**를 사용함 <br>

• fork( )를 통해 **4개의 자식 프로세스**를 생성하고, 각 프로세스에 /usr/include 디렉토리 속 파일들을 분배함 <br>

• 자식들은 병렬로 #include 개수 탐색을 수행 → exit( )로 결과 전달 후 부모가 wait( )로 자식을 수거함 <br>

• 이와 대조적으로, **하나의 프로세스**가 모든 파일을 순차적으로 처리하는 싱글 프로세싱을 별도로 수행함 <br>

• 두 방식을 비교하기 위해 gettimeofday( )와 getrusage( )를 이용해 수행 시간과 사용자 및 시스템 모드 시간을 측정함 

<br><br>

## 🔹 프로젝트 과정
